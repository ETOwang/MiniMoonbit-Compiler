package moonbitlang/minimbt/typing

//类型推导上下文
pub let extenv : Map[String, @types.Type] = {
    "print_int":Fun([Int], Unit),
    "print_char":Fun([Int], Unit),
    //todo;
}
struct LocalCtx @immut/hashmap.T[String, Ty]

// 类型缺失时生成新变量
fn new_tear() -> Type{
    Var(~t = None)
}

//找到变量类型
fn repr(self: Type) -> Type{
    match self{
        Var(~t = Some(ty)) as tvar =>{
            let actual_ty = ty.repr()
            tvar.t = Some(actual_ty)
            actual_ty
        }
        ty => ty
    }
}

//归一化
//fn unify(t1: Ty, t2: Ty) -> Unit!TyErr{
    let t1 = t1.repr()
    let t2 = t2.repr()
    if physical_equal(t1, t2) {return}
    match(t1, t2){
        (Int, Int) | (Bool, Bool) => ()
        (TVar(~t=None) as tvar, ty) | (ty, TVar(~t=None) as tvar) => {
            check_occur!(tvar, ty)
            tvar.t = Some(ty)
        }
        //Todo;
        //handle the function, tuple, and array Type
        // 函数类型处理
        (Fun(params1, ret1), Fun(params2, ret2)) => {
            if params1.len() != params2.len() {
                raise TyErr
            }
            for (p1, p2) in params1.iter().zip(params2.iter()) {
                unify(p1, p2)?
            }
            unify(ret1, ret2)?;
        }

        // 元组类型处理
        (Tuple(types1), Tuple(types2)) => {
            if types1.len() != types2.len() {
                raise TyErr;
            }
            for (t1_elem, t2_elem) in types1.iter().zip(types2.iter()) {
                unify(t1_elem, t2_elem)?
            }
        },

        // 数组类型处理
        (Array(elem_type1), Array(elem_type2)) => {
            unify(elem_type1, elem_type2)?
        }

        _ => raise TyErr
    }
}

//类型推断
fn infer(ctx : LocalCtx, e : Syntax) -> Type!TyErr {
    match e {
        Int(_) => Int; Bool(_) => Bool
        Double(_) => Double
        Var(x) => 
        match ctx._[x] {
            Some(t) => t
            //新类型变量
            None =>
                let t = new_tvar()
                extenv[x] = t
                t
        }

        //递归函数类型推导
        LetRec({name : (f, t), params, body}, rest) =>{
            let env_with_f = ctx._.insert(f, t)
            let params_ty = params.map(fn { (_, t) => t})
            let mut env_with_params = env_with_f
            for p in params{
                env_with_params = env_with_params.insert(p.0, p.1)
            }
            let body_ty = infer!(env_with_params, body)
            unify!(t, Fun(params_ty, body_ty))
            infer!(env_with_f, rest)
        }

        //函数调用类型推导
        App(f, args) => {
            let ret_ty = new_tvar()
            let f_ty = infer!(ctx, f)
            let args_ty = []
            for a in args {
                args_ty.push(infer!(ctx, a))
            }
            unify!(f_ty, Fun(args_ty, ret_ty))
            ret_ty
        }

        //一元负号推导
        Neg(expr, kind) => {
            let ty = infer(ctx, expr)?;  // 推断表达式类型
            match kind {
                Some(Kind::Int) => {
                    unify(ty, Int)?;
                    Int
                }
                Some(Kind::Double) => {
                    unify(ty, Double)?;
                    Double
                }
            None => raise TyErr  // 需要明确的类型
            }
        }

        //二元算术推导
        Prim(lhs, rhs, op, kind) => {
            let lhs_ty = infer(ctx, lhs)?;
            let rhs_ty = infer(ctx, rhs)?;
            match op {
                Op::Add | Op::Sub | Op::Mul | Op::Div => {
                    // 确保左右操作数类型一致
                    unify(lhs_ty, rhs_ty)?;
                    match kind {
                        Some(Kind::Int) => {
                            unify(lhs_ty, Int)?;
                            Int
                        }
                        Some(Kind::Double) => {
                            unify(lhs_ty, Double)?;
                            Double
                        }
                        None => raise TyErr
                    }
                }
            }
        }

        //数组类型推导
        Array(arr_expr, len_expr) => {
            let elem_ty = infer(ctx, arr_expr)?;  // 推断数组元素类型
            let len_ty = infer(ctx, len_expr)?;   // 推断数组长度表达式的类型
            if !len_ty.op_equal(Int) {
                raise TyErr;  // 数组长度必须是 Int 类型
            }
        Array(elem_ty)
        }

        //If推导
        If(cond, then_expr, else_expr) => {
            let cond_ty = infer(ctx, cond)?;
            unify(cond_ty, Bool)?;  // 条件必须是布尔类型
            let then_ty = infer(ctx, then_expr)?;
            let else_ty = infer(ctx, else_expr)?;
            unify(then_ty, else_ty)?;  // 两个分支的类型必须一致
            then_ty
        }

        //比较类型推导
        Eq(lhs, rhs) | LE(lhs, rhs) => {
            let lhs_ty = infer(ctx, lhs)?;
            let rhs_ty = infer(ctx, rhs)?;
            unify(lhs_ty, rhs_ty)?;  // 左右操作数类型必须一致
            Bool
        }
    }
}

//类型清理
fn deref_type(t:Type) -> Type{
    match t {
        Fun(params, result) =>
          Fun(params.map(fn {t => deref_type(t)}), deref_type(result))
        Tuple(types) => Tuple(types.map(fn {t => deref_type(t)}))
        Array(t) => Array(deref_type(t))
        Var(~t = Some(t)) as tvar => {
            let t = deref_type(t)
            tvar.t = Some(t)
            t
        }
        Var(~t = None) as tvar => {
            tvar.t = Some(Unit)
            Unit
        }
        t => t
    }
}

// 对整个语法树进行清理
fn deref_term(syntax: Syntax) -> Syntax {
    match syntax {
        //整数、布尔值、变量无需处理
        Int(_) | Bool(_) => syntax,
        Var(x) => Var(x),

        // 对 let 表达式，清理绑定的类型和剩余部分
        Let(x, t, expr1, expr2) => {
            let new_t = deref_type(t);
            let new_expr1 = deref_term(*expr1);
            let new_expr2 = deref_term(*expr2);
            Let(x, new_t, Box::new(new_expr1), Box::new(new_expr2))
        }

        // 对递归函数 letrec 表达式，清理函数体及其他部分
        LetRec { name, params, body, rest } => {
            let new_body = deref_term(*body);
            let new_rest = deref_term(*rest);
            LetRec {
                name: (name.0, deref_type(name.1)),
                params: params.into_iter()
                    .map(|(param, ty)| (param, deref_type(ty)))
                    .collect(),
                body: Box::new(new_body),
                rest: Box::new(new_rest),
            }
        }

        // 对函数应用表达式，清理函数及参数类型
        App(f, args) => {
            let new_f = deref_term(*f);
            let new_args = args.into_iter().map(deref_term).collect();
            App(Box::new(new_f), new_args)
        }

        // 对 tuple 表达式，清理每个元素类型
        Tuple(elements) => {
            let new_elements = elements.into_iter().map(deref_term).collect();
            Tuple(new_elements)
        }

        // 对数组表达式，清理元素类型
        Array(arr_expr, len_expr) => {
            let new_arr_expr = deref_term(*arr_expr);
            let new_len_expr = deref_term(*len_expr);
            Array(Box::new(new_arr_expr), Box::new(new_len_expr))
        }

        // 其他表达式类型，如函数定义、数组等
        _ => syntax
    }
}

//主函数
pub fn typing(e : Syntax) -> Syntax!TyErr {
    unify!(Unit, infer!(@immut/sorted_map.empty(), e))
    for ext_f, ext_t in extenv {
        extenv[ext_f] = deref_type(ext_t)
    }
    deref_term(e)
}